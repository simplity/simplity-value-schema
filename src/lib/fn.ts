import {
  GenericErrorCode,
  ValidationFn,
  ValidationResult,
  Value,
  ValueSchema,
  ValueType,
} from './types';

/**
 * creates a function that can be used to validate a value against the supplied value-schema
 * @param schema schema json. Typically entered as met-date by designers, or generated by utilities
 * @returns validation function
 */
export function createValidationFn(schema: ValueSchema): ValidationFn {
  /**
   * all the parameters required for validation
   */
  let errorId = schema.errorId;
  let textErrorId = errorId || GenericErrorCode.InvalidValue;
  let minLength = schema.minLength || 1;
  let maxLength = schema.maxLength || DEFAULT_MAX_LENGTH;
  let regex = schema.regex;
  let regexp = regex ? new RegExp(regex) : undefined;
  let minValue = 0; //we deal with business data, and hence 0 is a better default than MIN_SAFE_INTEGER
  let maxValue = Number.MAX_SAFE_INTEGER;

  switch (schema.valueType) {
    case ValueType.Text:
      return createTextFn({ textErrorId, maxLength, minLength, regexp });

    case ValueType.Boolean:
      return validateBoolean;

    case ValueType.Integer:
    case ValueType.Decimal:
      if (schema.minValue !== undefined) {
        minValue = schema.minValue;
      }

      if (schema.maxValue !== undefined) {
        maxValue = schema.maxValue;
      }

      return createNumberFn({
        textErrorId: GenericErrorCode.InvalidNumber,
        errorId: errorId || GenericErrorCode.InvalidNumber,
        factor:
          schema.nbrDecimalPlaces === undefined
            ? 1
            : 10 ** schema.nbrDecimalPlaces,
        maxLength, //not restricting so that we get maxValue error rather than maxLength error
        minLength,
        maxValue,
        minValue,
        regexp: NUMBER_REGEX, //we accept decimal values for integer!!
      });

    case ValueType.Date:
      if (schema.minValue !== undefined) {
        minValue = schema.minValue * MS_PER_DAY;
      } else {
        minValue = MAX_DATE_DIFF;
      }

      if (schema.maxValue !== undefined) {
        maxValue = schema.maxValue * MS_PER_DAY;
      } else {
        maxValue = MAX_DATE_DIFF;
      }

      return createDateFn({
        textErrorId: GenericErrorCode.InvalidDate,
        errorId: errorId || GenericErrorCode.InvalidNumber,
        maxLength,
        minLength: 1,
        maxValue,
        minValue,
        regexp: DATE_REGEX,
      });

    case ValueType.Timestamp:
      return createTextFn({
        textErrorId: GenericErrorCode.InvalidValue,
        maxLength: 25,
        minLength: 1,
        regexp: TIME_STAMP_REGEX,
      });

    case ValueType.Ds:
    case ValueType.Array:
      //TODO: we are not yet ready. we validate it as just text
      return createTextFn({
        textErrorId: GenericErrorCode.InvalidValue,
        maxLength: 10000,
        minLength: 1,
        regexp: undefined,
      });
  }
}

/*
 * createXxxFn functions are  designed to minimize the scope of teh closure around the returned function
 */
function createTextFn(schema: TextSchema): ValidationFn {
  return (value: Value) => {
    return validateString(schema, value);
  };
}

function createNumberFn(schema: NumberSchema): ValidationFn {
  return (value: Value) => {
    return validateNumber(schema, value);
  };
}

function createDateFn(schema: DateSchema): ValidationFn {
  return (value: Value) => {
    return validateDate(schema, value);
  };
}

/*
 * run-time validation functions that use our internal schema parameters
 */
function validateString(schema: TextSchema, value: Value): ValidationResult {
  if (value === undefined) {
    return {
      errorId: GenericErrorCode.InvalidValue,
    };
  }

  const s = value.toString();
  const len = s.length;
  if (len < schema.minLength!) {
    return {
      errorId: GenericErrorCode.MinLength,
      params: [schema.minLength + ''],
    };
  }

  if (len < schema.maxLength!) {
    return {
      errorId: GenericErrorCode.MaxLength,
      params: [schema.maxLength + ''],
    };
  }

  if (schema.regexp && schema.regexp.test(s) === false) {
    return { errorId: schema.textErrorId };
  }

  return { value: s };
}

function validateNumber(schema: NumberSchema, value: Value): ValidationResult {
  const res = validateString(schema, value);
  if (res.errorId) {
    return res;
  }

  let nbr = Number.parseFloat(res.value! as string);
  if (Number.isNaN(nbr)) {
    return { errorId: GenericErrorCode.InvalidNumber };
  }

  //make it an integer or decimal to the right number of decimal places
  nbr = Math.round(nbr * schema.factor) / schema.factor;

  if (nbr < schema.minValue) {
    return {
      errorId: GenericErrorCode.MinValue,
      params: [schema.minValue + ''],
    };
  }

  if (nbr > schema.maxValue) {
    return {
      errorId: GenericErrorCode.MaxValue,
      params: [schema.maxValue + ''],
    };
  }

  return { value: nbr };
}

function validateBoolean(value: Value): ValidationResult {
  if (value === undefined) {
    return { errorId: GenericErrorCode.InvalidBoolean };
  }

  const s = value.toString().toLowerCase();
  if (s === 'true' || s == '1') {
    return { value: true };
  }
  if (s === 'false' || s == '0') {
    return { value: false };
  }
  return { errorId: GenericErrorCode.InvalidBoolean };
}

function validateDate(schema: DateSchema, value: Value): ValidationResult {
  const res = validateString(schema, value);
  if (res.errorId) {
    return res;
  }

  //str is guaranteed to be yyyy-mm-dd
  const str = res.value as string;
  const arr = str.split('-');
  const yyyy = Number.parseInt(arr[0], 10);
  const mm = Number.parseInt(arr[1], 10) - 1; //month index
  const dd = Number.parseInt(arr[2], 10);
  const n = Date.parse(str + ZERO_TIME);
  if (!n) {
    return { errorId: GenericErrorCode.InvalidDate };
  }

  const date = new Date(yyyy, mm, dd, 0, 0, 0, 0);

  if (
    dd !== date.getDate() ||
    mm !== date.getMonth() ||
    yyyy !== date.getFullYear()
  ) {
    return { errorId: GenericErrorCode.InvalidDate };
  }

  const dateMs = date.valueOf();

  //get local date, and construct a UTC for that that with zero time components
  const now = new Date();
  const nowMs = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    0,
    0,
    0,
    0
  ).valueOf();

  // minValue is already in ms
  if (dateMs < nowMs - schema.minValue) {
    return {
      errorId: GenericErrorCode.EarliestDate,
      params: [schema.minValue.toString()],
    };
  }

  if (dateMs > nowMs + schema.maxValue) {
    return {
      errorId: GenericErrorCode.LatestDate,
      params: [schema.maxValue.toString()],
    };
  }

  // note that we use date-string as the value for date fields
  return { value: str };
}

const MS_PER_DAY = 24 * 60 * 60 * 100;
// by default we allow  1000 years from current date as valid date
const MAX_DATE_DIFF = 365000 * MS_PER_DAY;
const NUMBER_REGEX = /^-?\d*\.?\d*$/;
const DATE_REGEX = /^\d\d\d\d-\d\d-\d\d$/;
const TIME_STAMP_REGEX =
  /^\d\d\d\d-\d\d-\d\dT[0-2]\d:[0-5]\d:[0-6]\d\.\d\d\dZ$/;
const ZERO_TIME = 'T00:00:00.000Z';
const DEFAULT_MAX_LENGTH = 1000;

/**
 * type definitions internally used for improving code quality
 */
type TextSchema = {
  textErrorId: string;
  minLength: number;
  maxLength: number;
  regexp?: RegExp;
};

type DateSchema = TextSchema & {
  minValue: number;
  maxValue: number;
  errorId: string;
};

type NumberSchema = DateSchema & {
  factor: number;
};
