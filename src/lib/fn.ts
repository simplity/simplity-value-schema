import {
  DEFAULT_DAYS_RANGE,
  DEFAULT_MAX_CHARS,
  DEFAULT_MAX_NUMBER,
  SchemaValidationFn,
  SchemaValidationResult,
  Value,
  ValueSchema,
  DEFAULT_NBR_DECIMALS,
  SchemaErrorCode,
  ValueType,
} from './types';

/**
 * creates a function that can be used to validate a value against the supplied value-schema
 * @param schema schema json. Typically entered as met-date by designers, or generated by utilities
 * @returns validation function
 */
export function createValidationFn(schema: ValueSchema): SchemaValidationFn {
  /**
   * all the parameters required for validation
   */
  let minLength = schema.minLength || 0;
  let maxLength = schema.maxLength || DEFAULT_MAX_CHARS;
  let regex = schema.regex;
  let regexp = regex ? new RegExp(regex) : undefined;
  let minValue = 0; //we deal with business data, and hence negative numbers not allowed by default
  let maxValue = DEFAULT_MAX_NUMBER;

  switch (schema.valueType) {
    case ValueType.Text:
      return createTextFn({
        maxLength,
        minLength,
        regexp,
      });

    case ValueType.Boolean:
      return validateBoolean;

    case ValueType.Integer:
      if (schema.minValue !== undefined) {
        minValue = Math.round(schema.minValue);
      }

      if (schema.maxValue !== undefined) {
        maxValue = Math.round(schema.maxValue);
      }

      return createNumberFn({
        factor: 1,
        maxValue,
        minValue,
      });

    case ValueType.Decimal:
      let factor = DEFAULT_FACTOR;
      let nbr = schema.nbrDecimalPlaces && schema.nbrDecimalPlaces;
      if (nbr && nbr > 0) {
        nbr = Math.round(nbr);
        factor = 10 ** nbr;
      }

      if (schema.minValue !== undefined) {
        minValue = roundIt(schema.minValue, factor);
      }

      if (schema.maxValue !== undefined) {
        maxValue = roundIt(schema.maxValue, factor);
      }
      return createNumberFn({
        factor,
        maxValue,
        minValue,
      });

    case ValueType.Date:
    case ValueType.Timestamp:
      if (schema.minValue !== undefined) {
        minValue = Math.round(schema.minValue);
      } else {
        minValue = -DEFAULT_DAYS_RANGE;
      }

      if (schema.maxValue !== undefined) {
        maxValue = Math.round(schema.maxValue);
      } else {
        maxValue = DEFAULT_DAYS_RANGE;
      }

      if (schema.valueType === 'date') {
        return createDateFn({
          maxValue,
          minValue,
        });
      }
      return createTimestampFn({
        maxValue,
        minValue,
      });
  }
}

/*
 * createXxxFn functions are  designed to minimize the scope of teh closure around the returned function
 */
function createTextFn(schema: TextSchema): SchemaValidationFn {
  return (value: any) => {
    return validateString(schema, value);
  };
}

function createNumberFn(schema: NumberSchema): SchemaValidationFn {
  return (value: any) => {
    return validateNumber(schema, value);
  };
}

function createDateFn(schema: DateSchema): SchemaValidationFn {
  return (value: any) => {
    return validateDate(schema, value);
  };
}

function createTimestampFn(schema: DateSchema): SchemaValidationFn {
  return (value: any) => {
    return validateTimestamp(schema, value);
  };
}

/*
 * run-time validation functions that use our internal schema parameters
 */
function validateString(
  schema: TextSchema,
  value: Value
): SchemaValidationResult {
  if (value === undefined || value === null || Number.isNaN(value)) {
    return TEXT_ERROR;
  }

  const s = value.toString().trim();
  const len = s.length;
  if (len < schema.minLength!) {
    return {
      error: {
        code: SchemaErrorCode.MinValue,
        params: [schema.minLength + ''],
      },
    };
  }

  if (len > schema.maxLength!) {
    return {
      error: {
        code: SchemaErrorCode.MaxLength,
        params: [schema.maxLength + ''],
      },
    };
  }

  if (schema.regexp && schema.regexp.test(s) === false) {
    return TEXT_ERROR;
  }

  return { value: s };
}

function validateNumber(
  schema: NumberSchema,
  value: Value
): SchemaValidationResult {
  const str = (value + '').trim();
  if (!NUMBER_REGEX.test(str)) {
    return NUMBER_ERROR;
  }

  let nbr = Number.parseFloat(str);
  if (Number.isNaN(nbr)) {
    return NUMBER_ERROR;
  }

  //make it an integer or decimal to the right number of decimal places
  nbr = Math.round(nbr * schema.factor) / schema.factor;

  if (nbr < schema.minValue) {
    return {
      error: {
        code: SchemaErrorCode.MinValue,
        params: [schema.minValue + ''],
      },
    };
  }

  if (nbr > schema.maxValue) {
    return {
      error: {
        code: SchemaErrorCode.MaxValue,
        params: [schema.maxValue + ''],
      },
    };
  }

  return { value: nbr };
}

function validateBoolean(value: Value): SchemaValidationResult {
  if (!value) {
    return { value: false };
  }

  const s = value.toString().trim().toLowerCase();
  if (s === 'true' || s == '1') {
    return { value: true };
  }
  if (s === 'false' || s == '0') {
    return { value: false };
  }
  return BOOL_ERROR;
}

function validateDate(
  schema: DateSchema,
  value: Value
): SchemaValidationResult {
  const str = (value + '').trim();
  if (!DATE_REGEX.test(str)) {
    return DATE_ERROR;
  }
  const yyyy = Number.parseInt(str.substring(0, 4), 10);
  const mm = Number.parseInt(str.substring(5, 7), 10) - 1; //month index
  const dd = Number.parseInt(str.substring(8, 10), 10);
  const dateMs = Date.UTC(yyyy, mm, dd);
  const date = new Date(dateMs);

  if (
    dd !== date.getDate() ||
    mm !== date.getMonth() ||
    yyyy !== date.getFullYear()
  ) {
    return DATE_ERROR;
  }

  //get local date
  const now = new Date();
  const nowYear = now.getFullYear();
  const nowMon = now.getMonth();
  const nowDate = now.getDate();

  //Date constructor allows us to just add days to get the desired date object
  let refMs = Date.UTC(nowYear, nowMon, nowDate + schema.minValue);
  if (dateMs < refMs) {
    return {
      error: {
        code: SchemaErrorCode.EarliestDate,
        params: [new Date(refMs).toISOString().substring(0, 10)],
      },
    };
  }
  refMs = Date.UTC(nowYear, nowMon, nowDate + schema.maxValue);
  if (dateMs > refMs) {
    return {
      error: {
        code: SchemaErrorCode.LatestDate,
        params: [new Date(refMs).toISOString().substring(0, 10)],
      },
    };
  }
  // note that we use date-string as the value for date fields
  return { value: str };
}

function validateTimestamp(
  schema: DateSchema,
  value: Value
): SchemaValidationResult {
  const valueStr = (value + '').trim();
  if (valueStr.length !== 24) {
    return STAMP_ERROR;
  }

  let str = valueStr.substring(0, 10);
  const res = validateDate(schema, str);
  if (res.error) {
    if (res.error.params) {
      //max-min error
      return res;
    }
    return STAMP_ERROR;
  }

  str = valueStr.substring(10, 24);
  if (!TIME_REGEX.test(str)) {
    return STAMP_ERROR;
  }

  const hrs = Number.parseInt(str.substring(1, 3), 10);
  const mns = Number.parseInt(str.substring(4, 6), 10);
  const secs = Number.parseFloat(str.substring(7, 13));
  if (
    hrs > 24 ||
    mns > 59 ||
    secs > 59 || //we will not validate leap second!!
    (hrs === 24 && (mns > 0 || secs > 0))
  ) {
    return STAMP_ERROR;
  }

  return { value: valueStr };
}

function roundIt(n: number, factor: number): number {
  return Math.round(n * factor) / factor;
}

const DEFAULT_FACTOR = 10 ** DEFAULT_NBR_DECIMALS;
const NUMBER_REGEX = /^-?\d*\.?\d*$/;
const DATE_REGEX = /^\d\d\d\d-\d\d-\d\d$/;
const TIME_REGEX = /^T\d\d:\d\d:\d\d\.\d\d\dZ$/;

const TEXT_ERROR: SchemaValidationResult = {
  error: { code: SchemaErrorCode.InvalidText },
};
const BOOL_ERROR: SchemaValidationResult = {
  error: { code: SchemaErrorCode.InvalidBoolean },
};
const NUMBER_ERROR: SchemaValidationResult = {
  error: { code: SchemaErrorCode.InvalidNumber },
};
const DATE_ERROR: SchemaValidationResult = {
  error: { code: SchemaErrorCode.InvalidDate },
};
const STAMP_ERROR: SchemaValidationResult = {
  error: { code: SchemaErrorCode.InvalidTimestamp },
};

/**
 * type definitions internally used for improving code quality
 */
type TextSchema = {
  minLength: number;
  maxLength: number;
  regexp?: RegExp;
};

type DateSchema = {
  minValue: number;
  maxValue: number;
};

type NumberSchema = DateSchema & {
  factor: number;
};
